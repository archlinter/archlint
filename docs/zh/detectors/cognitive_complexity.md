# 认知复杂度

**ID:** `cognitive_complexity` | **严重程度:** 中 (默认)

认知复杂度不仅仅关乎你的代码有多少个分支，更关乎人类大脑理解这段逻辑到底需要付出多少努力。它是“技术上正确”与“代码可读”之间的本质区别。

## 为什么这是一个代码异味

- **大脑堆栈溢出**：人类并不擅长同时处理五个层级的嵌套逻辑和复杂的布尔代数。当心理负荷过高时，我们就会开始犯错。
- **隐形 Bug**：Bug 最喜欢躲在深层嵌套的 `if` 语句和长串三元运算符的阴影里。
- **评审摩擦**：如果一个资深开发在 PR 评审中需要花 20 分钟才能看懂一个 30 行的函数，那这段代码就太复杂了。

## 如何计算

认知复杂度根据以下各项计算：

1.  **结构性增量**: `if`、`else`、`switch`、`for`、`while`、`do-while`、`catch`、三元运算符和逻辑序列。
2.  **嵌套惩罚**: 控制结构的增量根据其嵌套级别而增加。
3.  **特殊情况**: `switch` 无论有多少个 case，整个块只计算一次。

## 如何修复

1.  **扁平化逻辑**: 使用卫语句 (提前返回) 来减少嵌套。
2.  **提取方法**: 将嵌套块或复杂条件移动到小而集中的函数中。
3.  **简化表达式**: 将复杂的布尔条件分解为中间变量或函数。
4.  **替换嵌套 If**: 考虑使用查找表或策略模式。

## 配置

```yaml
rules:
  cognitive_complexity:
    severity: medium
    max_complexity: 15
```

## ESLint 规则

此检测器可作为 ESLint 规则使用，以便在编辑器中获得实时反馈。

```javascript
// eslint.config.js
export default [
  {
    rules: {
      '@archlinter/no-high-cognitive-complexity': 'warn',
    },
  },
];
```
