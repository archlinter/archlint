# 認知的複雑度

**ID:** `cognitive_complexity` | **重要度:** 中 (デフォルト)

認知的複雑度は、単にコードの分岐がいくつあるかではなく、人間がそのロジックを理解するのにどれほどのエネルギーを必要とするかを測定します。「技術的に正しい」ことと「読みやすい」ことの差を数値化したものです。

## なぜこれが「不吉な臭い」なのか

- **脳内スタックのオーバーフロー**: 人間は、5段階ものネストや複雑な論理演算を同時に把握し続けるのが苦手です。メンタルモデルの負荷が高すぎると、見落としやミスが発生しやすくなります。
- **見えないバグ**: 深いネストや三項演算子の影には、バグが潜みやすいものです。
- **レビューの摩擦**: PRレビューで、シニアエンジニアが30行の関数の理解に20分もかかっているとしたら、それはそのコードが複雑すぎるサインです。

## 計算方法

認知的複雑度は以下に基づいて計算されます：

1.  **構造的な増加**: `if`、`else`、`switch`、`for`、`while`、`do-while`、`catch`、三項演算子、および論理シーケンス。
2.  **ネストによるペナルティ**: 制御構造に対する増加分は、そのネストレベルに基づいて増加します。
3.  **特殊なケース**: `switch` は、ケースの数に関わらず、ブロック全体で1回だけカウントされます。

## 修正方法

1.  **ロジックの平坦化**: ガード句（早期リターン）を使用してネストを減らします。
2.  **メソッドの抽出**: ネストされたブロックや複雑な条件を、小さく焦点の絞られた関数に移動します。
3.  **式の簡略化**: 複雑な論理条件を中間変数や関数に分割します。
4.  **ネストされた If の置換**: ルックアップテーブルや Strategy パターンなどの使用を検討してください。

## 設定

```yaml
rules:
  cognitive_complexity:
    severity: medium
    max_complexity: 15
```

## ESLint ルール

このディテクターは、エディターでリアルタイムのフィードバックを得るための ESLint ルールとして利用可能です。

```javascript
// eslint.config.js
export default [
  {
    rules: {
      '@archlinter/no-high-cognitive-complexity': 'warn',
    },
  },
];
```
