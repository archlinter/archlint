# 認知的複雑度

**ID:** `cognitive_complexity` | **重要度:** 中 (デフォルト)

このディテクターは、認知的複雑度（Cognitive Complexity）が高い関数を特定します。認知的複雑度は、単にコードの経路数ではなく、コードの理解がいかに困難かを測定します。

## なぜこれが「不吉な臭い」なのか

- **高い精神的負荷**: 深くネストされたロジックや複雑な論理式は、開発者が状態を頭の中に保持することを困難にします。
- **メンテナンスのリスク**: 理解しにくいコードは、修正時にバグが発生しやすくなります。
- **隠れたバグ**: ロジックのエラーは、深くネストされた構造の中に隠れていることがよくあります。

## 計算方法

認知的複雑度は以下に基づいて計算されます：

1.  **構造的な増加**: `if`、`else`、`switch`、`for`、`while`、`do-while`、`catch`、三項演算子、および論理シーケンス。
2.  **ネストによるペナルティ**: 制御構造に対する増加分は、そのネストレベルに基づいて増加します。
3.  **特殊なケース**: `switch` は、ケースの数に関わらず、ブロック全体で1回だけカウントされます。

## 修正方法

1.  **ロジックの平坦化**: ガード句（早期リターン）を使用してネストを減らします。
2.  **メソッドの抽出**: ネストされたブロックや複雑な条件を、小さく焦点の絞られた関数に移動します。
3.  **式の簡略化**: 複雑な論理条件を中間変数や関数に分割します。
4.  **ネストされた If の置換**: ルックアップテーブルや Strategy パターンなどの使用を検討してください。

## 設定

```yaml
rules:
  cognitive_complexity:
    severity: medium
    max_complexity: 15
```

## ESLint ルール

このディテクターは、エディターでリアルタイムのフィードバックを得るための ESLint ルールとして利用可能です。

```javascript
// eslint.config.js
export default [
  {
    rules: {
      '@archlinter/no-high-cognitive-complexity': 'warn',
    },
  },
];
```
